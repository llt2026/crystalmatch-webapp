import { NextApiRequest, NextApiResponse } from 'next';
import { calculate } from 'bazi-calculator-by-alvamind';

// 五行映射
const fiveElementsMap: Record<string, string> = {
  '甲': 'wood', '乙': 'wood',
  '丙': 'fire', '丁': 'fire',
  '戊': 'earth', '己': 'earth',
  '庚': 'metal', '辛': 'metal',
  '壬': 'water', '癸': 'water',
  '子': 'water', '午': 'fire',
  '丑': 'earth', '未': 'earth',
  '寅': 'wood', '申': 'metal',
  '卯': 'wood', '酉': 'metal',
  '辰': 'earth', '戌': 'earth',
  '巳': 'fire', '亥': 'water'
};

// 生肖映射
const zodiacMap: Record<string, string> = {
  '子': '鼠', '丑': '牛', '寅': '虎', '卯': '兔',
  '辰': '龙', '巳': '蛇', '午': '马', '未': '羊',
  '申': '猴', '酉': '鸡', '戌': '狗', '亥': '猪'
};

// 接口类型定义
type BaziFallbackResponse = {
  pillars: {
    year: string;
    month: string;
    day: string;
  };
  zodiac: string;
  fiveElements: {
    metal: number;
    wood: number;
    water: number;
    fire: number;
    earth: number;
  };
  primaryElement: string;
  missingElements: string[];
  isFallback: boolean;
};

type ErrorResponse = {
  error: string;
};

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<BaziFallbackResponse | ErrorResponse>
) {
  // 只接受POST请求
  if (req.method !== 'POST') {
    return res.status(400).json({ error: '仅支持POST请求' });
  }

  try {
    const { birthday } = req.body;

    // 验证生日格式
    if (!birthday || !/^\d{4}-\d{2}-\d{2}$/.test(birthday)) {
      return res.status(400).json({ error: '生日格式无效，请使用YYYY-MM-DD格式' });
    }

    // 将生日拼接为完整时间字符串（中午12点）
    const dateTimeStr = `${birthday} 12:00`;
    const dateTime = new Date(dateTimeStr);

    // 验证日期有效性
    if (isNaN(dateTime.getTime())) {
      return res.status(400).json({ error: '无效的日期' });
    }

    // 解析日期
    const year = dateTime.getFullYear();
    const month = dateTime.getMonth() + 1; 
    const day = dateTime.getDate();
    const hour = 12; // 默认中午12点

    // 使用bazi-calculator-by-alvamind计算八字
    const baziResult = calculate(year, month, day, hour);
    
    // 提取年月日柱
    const yearPillar = baziResult.tianGan.year + baziResult.diZhi.year;
    const monthPillar = baziResult.tianGan.month + baziResult.diZhi.month;
    const dayPillar = baziResult.tianGan.day + baziResult.diZhi.day;
    
    // 获取生肖（地支对应的生肖）
    const zodiac = zodiacMap[baziResult.diZhi.year];

    // 计算五行统计
    const fiveElementsCount = {
      metal: 0,
      wood: 0,
      water: 0,
      fire: 0,
      earth: 0
    };

    // 统计年月日柱中各五行的数量
    const allCharacters = [
      baziResult.tianGan.year, baziResult.diZhi.year,   // 年柱天干地支
      baziResult.tianGan.month, baziResult.diZhi.month, // 月柱天干地支
      baziResult.tianGan.day, baziResult.diZhi.day      // 日柱天干地支
    ];

    allCharacters.forEach(char => {
      const element = fiveElementsMap[char];
      if (element) {
        fiveElementsCount[element as keyof typeof fiveElementsCount]++;
      }
    });

    // 确定主导五行和缺失五行
    const elementsEntries = Object.entries(fiveElementsCount);
    elementsEntries.sort((a, b) => b[1] - a[1]);
    
    const primaryElement = elementsEntries[0][0];
    const missingElements = elementsEntries
      .filter(([_, count]) => count === 0)
      .map(([element, _]) => element);

    // 构建响应
    const response: BaziFallbackResponse = {
      pillars: {
        year: yearPillar,
        month: monthPillar,
        day: dayPillar
      },
      zodiac,
      fiveElements: fiveElementsCount,
      primaryElement,
      missingElements,
      isFallback: true  // 恒为true，表示简化版
    };

    return res.status(200).json(response);
  } catch (error) {
    console.error('八字计算错误:', error);
    return res.status(400).json({ error: '八字计算失败' });
  }
} 